package shcm.shsupercm.data.data;

import shcm.shsupercm.data.data.generation.DataAnnotationProcessor;
import shcm.shsupercm.data.framework.DataBlock;
import shcm.shsupercm.data.data.annotations.Data;

import java.util.HashMap;
import java.util.Map;

/**
 * Handles the registry of IData types annotated with @{@link Data}.<br>
 * This class will initialize the type registry process as soon as {@link #init(boolean)} is called(may be called from
 */
public class DataAnnotationRegistry {
    /**
     * Actual registry.
     */
    private static final Map<Class<? extends IData>, DataTypeHandler> REGISTRY = new HashMap<>();
    /**
     * Registry for data type class and id association.
     */
    private static final Map<DataRegistry.UniqueDataId, Class<? extends IData>> ID_CLASS_REGISTRY = new HashMap<>();
    /**
     * Has {@link #init(boolean)} ran already.
     */
    private static boolean initialized = false;

    /**
     * Will register all data handlers(that were generated by {@link DataAnnotationProcessor} from {@link IData} implementors annotated with @{@link Data}).
     * @param force if false, will not run the method if it has ran before.
     */
    public static synchronized void init(boolean force) {
        if(initialized) {
            if (!force)
                return;
            else {
                for (DataRegistry.UniqueDataId id : ID_CLASS_REGISTRY.keySet()) {
                    DataRegistry.remove(id);
                }
                REGISTRY.clear();
                ID_CLASS_REGISTRY.clear();
            }
        }

        long dataTypeNumber = -1;
        while (true) {
            try {
                register((DataTypeHandler<?>) Class.forName(DataAnnotationProcessor.GENERATED_CLASS_PACKAGE + '.' + DataAnnotationProcessor.GENERATED_CLASS_NAME + ++dataTypeNumber).newInstance());
                initialized = true;
            } catch (ClassNotFoundException e) {
                break;
            } catch (IllegalAccessException | InstantiationException e) {
                e.printStackTrace();
            }
        }
    }

    /**
     * Registers the {@link DataTypeHandler}&lt;T&gt; for type T.
     * @param handler the data type handler to register.
     */
    private static void register(DataTypeHandler<?> handler) {
        REGISTRY.put(handler.getType(), handler);
        ID_CLASS_REGISTRY.put(new DataRegistry.UniqueDataId(handler.dataTypeUID()), handler.getType());
        DataRegistry.register(new DataRegistryBuilder<>(handler));
    }

    /**
     * (Will optionally initialize automatic registry if it wasn't initialized already)<br>
     * Uses the {@link DataTypeHandler} associated with the {@code data}'s type to write the data into the data block.
     * @param dataBlock the data block to write to.
     * @param data the data to write into the data block.
     * @return the data block containing the written data.
     */
    @SuppressWarnings("unchecked")
    public static DataBlock write(DataBlock dataBlock, IData data) {
        init(false);
        return REGISTRY.get(data.getClass()).write(dataBlock, data);
    }

    /**
     * (Will optionally initialize automatic registry if it wasn't initialized already)<br>
     * Reads the given data block into a new {@link IData} instance.
     * @param dataBlock the data block to read from.
     * @return the read data.
     */
    public static IData read(DataBlock dataBlock) {
        init(false);
        return REGISTRY.get(ID_CLASS_REGISTRY.get(new DataRegistry.UniqueDataId((byte[]) dataBlock.get(DataRegistry.DATA_ID_IDENTIFIER)))).read(dataBlock);
    }

    /**
     * Gets the ID associated with the data type.
     * @param type the data to find the associated id for.
     * @return the id for the data type.
     */
    public static byte[] getID(Class<? extends IData> type) {
        init(false);
        return REGISTRY.get(type).dataTypeUID();
    }

    /**
     * An external handler for {@link IData} that is generated by {@link DataAnnotationProcessor}.
     * @param <T> the data type to handle.
     */
    public static abstract class DataTypeHandler<T extends IData> {
        /**
         * @return the class of the handled data type.
         */
        public abstract Class<T> getType();

        /**
         * Constructs a new instance of {@link T}.
         * @return a new instance of {@link T}.
         */
        public abstract T newT();

        /**
         * @return the unique id of this data type.
         */
        public abstract byte[] dataTypeUID();

        /**
         * Writes the data into the data block.
         * @param dataBlock the data block to write to.
         * @param data the data to write into the data block.
         * @return the data block containing the written data.
         */
        public abstract DataBlock write(DataBlock dataBlock, T data);

        /**
         * Reads data from the data block.
         * @param dataBlock the data block to read from.
         * @return the newly read data.
         */
        public abstract IData read(DataBlock dataBlock);
    }

    /**
     * A data registry builder optimized to {@link DataTypeHandler}s.
     * @param <T>
     */
    private static class DataRegistryBuilder<T extends IData> implements DataRegistry.Builder<T> {
        /**
         * Associated data type handler.
         */
        private final DataTypeHandler handler;

        public DataRegistryBuilder(DataTypeHandler<?> handler) {
            this.handler = handler;
        }

        @Override
        public T newT() {
            return (T) handler.newT();
        }

        @Override
        public T read(DataBlock dataBlock) {
            return (T) newT().read(dataBlock);
        }
    }
}
